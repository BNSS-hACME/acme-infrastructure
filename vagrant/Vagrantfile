# USB-C Ethernet adapter name as shown by: VBoxManage list bridgedifs | grep "^Name:"
# export BRIDGE_ADAPTER="en6: USB 10/100/1000 LAN" (add to .envrc)
BRIDGE_ADAPTER = ENV.fetch("BRIDGE_ADAPTER") { abort "Set BRIDGE_ADAPTER env var (run: VBoxManage list bridgedifs)" }

MACHINES = {
  "dns.server.acme" => {
    ip: "10.0.50.10",
    memory: 1024,
    cpus: 1,
    cloud_init: <<~YAML,
      package_update: true
      packages:
        - unbound
    YAML
  },
  "vpn.server.acme" => {
    ip: "10.0.50.11",
    memory: 1024,
    cpus: 1,
    cloud_init: <<~YAML,
      package_update: true
      packages:
        - openvpn
        - iptables
    YAML
  },
  "cloud.server.acme" => {
    ip: "10.0.50.12",
    memory: 2048,
    cpus: 2,
    cloud_init: <<~YAML,
      package_update: true
    YAML
  },
  "auth.server.acme" => {
    ip: "10.0.50.13",
    memory: 4096,
    cpus: 2,
    cloud_init: <<~YAML,
      package_update: true
    YAML
  },
  "ai.server.acme" => {
    ip: "10.0.50.14",
    memory: 2048,
    cpus: 2,
    cloud_init: <<~YAML,
      package_update: true
      packages:
        - curl
        - ca-certificates
    YAML
  },
  "dvwa.server.acme" => {
    ip: "10.0.50.50",
    memory: 1024,
    cpus: 1,
    cloud_init: <<~YAML,
      package_update: true
    YAML
  }
}

Vagrant.configure("2") do |config|
  config.vm.box = "cloud-image/debian-13"
  # https://portal.cloud.hashicorp.com/vagrant/discover/cloud-image/debian-13
  config.vm.box_version = "20260210.2384.0"

  config.vm.synced_folder ".", "/vagrant", disabled: true
  config.ssh.insert_key = false

  config.vm.define "router.server.acme" do |router|
    router.vm.hostname = "router.server.acme"

    # External: bridged to physical LAN, 10.0.10.50
    router.vm.network "public_network",
      bridge: BRIDGE_ADAPTER,
      ip: "10.0.10.50",
      netmask: "255.255.255.0"

    # Internal: shared with MACHINES, 10.0.50.1
    router.vm.network "private_network",
      ip: "10.0.50.1",
      netmask: "255.255.255.0",
      virtualbox__intnet: "acme-internal"

    # run: always so rules survive vagrant reload
    router.vm.provision "shell", name: "nat", run: "always", inline: <<~SHELL
      sysctl -w net.ipv4.ip_forward=1
      echo "net.ipv4.ip_forward = 1" > /etc/sysctl.d/90-router.conf

      # Detect interfaces dynamically based on IP subnets
      EXT_IF=$(ip -o -4 route show to default | head -n1 | awk '{print $5}')
      # Fallback to looking for the bridge network if Vagrant already removed default
      if [ -z "$EXT_IF" ]; then
        EXT_IF=$(ip -o -4 route show to exact 10.0.10.0/24 | head -n1 | awk '{print $3}')
      fi
      INT_IF=$(ip -o -4 route show to exact 10.0.50.0/24 | head -n1 | awk '{print $3}')

      # Setup NAT rules using the dynamically discovered interfaces
      iptables -t nat -C POSTROUTING -s 10.0.50.0/24 -o $EXT_IF -j MASQUERADE 2>/dev/null || \
        iptables -t nat -A POSTROUTING -s 10.0.50.0/24 -o $EXT_IF -j MASQUERADE
      iptables -C FORWARD -i $INT_IF -o $EXT_IF -j ACCEPT 2>/dev/null || \
        iptables -A FORWARD -i $INT_IF -o $EXT_IF -j ACCEPT
      iptables -C FORWARD -i $EXT_IF -o $INT_IF -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || \
        iptables -A FORWARD -i $EXT_IF -o $INT_IF -m state --state RELATED,ESTABLISHED -j ACCEPT

      # Ensure iptables rules persist across reboots.
      export DEBIAN_FRONTEND=noninteractive
      apt-get update -y
      apt-get install -y iptables-persistent
      # Save current IPv4 rules so they are restored on boot.
      if command -v netfilter-persistent >/dev/null 2>&1; then
        netfilter-persistent save
      else
        mkdir -p /etc/iptables
        iptables-save > /etc/iptables/rules.v4
      fi
      # Replace Vagrant NAT default route with physical LAN gateway.
      # 10.0.2.0/24 stays reachable as a directly-connected route on the vagrant interface.
      ip route del default via 10.0.2.2 2>/dev/null || true
      ip route add default via 10.0.10.1 dev $EXT_IF 2>/dev/null || true
      ip route del 10.0.10.1 via 10.0.2.2 dev enp0s8 2>/dev/null || true
    SHELL

    router.vm.provider :virtualbox do |vb|
      vb.name = "acme-router.server.acme"
      vb.memory = 2048
      vb.cpus = 1
    end
  end

  MACHINES.each do |name, opts|
    config.vm.define name do |node|
      node.vm.hostname = name

      # Internal network only — traffic exits via router.server.acme (10.0.50.1).
      node.vm.network "private_network",
        ip: opts[:ip],
        netmask: "255.255.255.0",
        virtualbox__intnet: "acme-internal"

      # Replace Vagrant NAT default route with router.server.acme.
      # 10.0.2.0/24 stays reachable as a directly-connected route on the Vagrant management interface — SSH unaffected.
      node.vm.provision "shell", name: "routing", run: "always", inline: <<~SHELL
        # Wait for the internal network interface to come up
        sleep 5
        INT_IF=$(ip -o -4 route show to exact 10.0.50.0/24 | head -n1 | awk '{print $3}')
        # Fallback to enp0s8 if detection fails (common in VirtualBox)
        if [ -z "$INT_IF" ]; then
          INT_IF="enp0s9"
        fi
        ip route del default via 10.0.2.2 2>/dev/null || true
        ip route add default via 10.0.50.1 dev $INT_IF 2>/dev/null || true
      SHELL

      if opts[:cloud_init]
        node.vm.cloud_init do |cloud_init|
          cloud_init.content_type = "text/cloud-config"
          cloud_init.inline = opts[:cloud_init]
        end
      end

      node.vm.provider :virtualbox do |vb|
        vb.name = "acme-#{name}"
        vb.memory = opts[:memory]
        vb.cpus = opts[:cpus]
      end
    end
  end
end
